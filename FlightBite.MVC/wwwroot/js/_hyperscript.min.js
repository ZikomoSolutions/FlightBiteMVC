(function (e, r) { if (typeof define === "function" && define.amd) { define([], r) } else { e._hyperscript = r() } })(typeof self !== "undefined" ? self : this, function () { return function () { "use strict"; function o(e, r) { for (var t in r) { if (r.hasOwnProperty(t)) { e[t] = r[t] } } return e } function r(e) { try { return JSON.parse(e) } catch (e) { t(e); return null } } function t(e) { if (console.error) { console.error(e) } else if (console.log) { console.log("ERROR: ", e) } } function u(e, r) { return new (e.bind.apply(e, [e].concat(r))) } var A = typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : this; var R = function () { var k = { "+": "PLUS", "-": "MINUS", "*": "MULTIPLY", "/": "DIVIDE", ".": "PERIOD", "\\": "BACKSLASH", ":": "COLON", "%": "PERCENT", "|": "PIPE", "!": "EXCLAMATION", "?": "QUESTION", "#": "POUND", "&": "AMPERSAND", ";": "SEMI", ",": "COMMA", "(": "L_PAREN", ")": "R_PAREN", "<": "L_ANG", ">": "R_ANG", "<=": "LTE_ANG", ">=": "GTE_ANG", "==": "EQ", "===": "EQQ", "!=": "NEQ", "!==": "NEQQ", "{": "L_BRACE", "}": "R_BRACE", "[": "L_BRACKET", "]": "R_BRACKET", "=": "EQUALS" }; function g(e) { return b(e) || w(e) || e === "-" || e === "_" } function O(e) { return b(e) || w(e) || e === "-" || e === "_" || e === ":" } function q(e) { return e === " " || e === "\t" || I(e) } function N(e) { return "[Line: " + e.line + ", Column: " + e.col + "]" } function I(e) { return e === "\r" || e === "\n" } function w(e) { return e >= "0" && e <= "9" } function b(e) { return e >= "a" && e <= "z" || e >= "A" && e <= "Z" } function A(e) { return e === "_" || e === "$" } function R(e) { return e === "`" || e === "^" } function C(n, r, e) { var t = true; l("WHITESPACE"); function i(e, r) { L.raiseParseError(e, r) } function a(e) { var r = u(e); if (r) { return r } else { i(this, "Expected '" + e + "' but found '" + d().value + "'") } } function o(e, r, t) { for (var n = 0; n < arguments.length; n++) { var a = arguments[n]; var i = u(a); if (i) { return i } } } function u(e) { if (d() && d().op && d().value === e) { return p() } } function s(e, r, t, n) { var a = l(e, r, t, n); if (a) { return a } else { i(this, "Expected one of " + JSON.stringify([e, r, t])) } } function l(e, r, t, n) { if (d() && d().type && [e, r, t, n].indexOf(d().type) >= 0) { return p() } } function f(e, r) { var t = c(e, r); if (t) { return t } else { i(this, "Expected '" + e + "' but found '" + d().value + "'") } } function c(e, r) { var r = r || "IDENTIFIER"; if (d() && d().value === e && d().type === r) { return p() } } function p() { var e = n.shift(); r.push(e); if (t) { l("WHITESPACE") } return e } function m() { var e = []; t = false; while (d() && d().type !== "WHITESPACE" && d().type !== "EOF") { e.push(p()) } t = true; return e } function v() { return n.length > 0 } function d(e) { var r; if (e) { var t = 0; do { r = n[t++] } while (r && r.type === "WHITESPACE") } else { r = n[0] } if (r) { return r } else { return { type: "EOF" } } } return { matchAnyOpToken: o, matchOpToken: u, requireOpToken: a, matchTokenType: l, requireTokenType: s, consumeToken: p, matchToken: c, requireToken: f, list: n, consumed: r, source: e, hasMore: v, currentToken: d, consumeUntilWhitespace: m } } function e(e) { var r = e; var t = []; var n = 0; var a = 0; var i = 1; var o = "<START>"; while (n < r.length) { if (h() === "-" && E() === "-") { l() } else { if (q(h())) { t.push(x()) } else if (!y() && h() === "." && b(E())) { t.push(f()) } else if (!y() && h() === "#" && b(E())) { t.push(c()) } else if (b(h()) || A(h())) { t.push(p()) } else if (w(h())) { t.push(m()) } else if (h() === '"' || h() === "'") { t.push(d()) } else if (k[h()]) { t.push(v()) } else if (R(h())) { t.push(s("RESERVED", h)) } else { if (n < r.length) { throw Error("Unknown token: " + h() + " ") } } } } return C(t, [], r); function u(e, r) { var t = s(e, r); t.op = true; return t } function s(e, r) { return { type: e, value: r, start: n, end: n + 1, column: a, line: i } } function l() { while (h() && !I(h())) { T() } T() } function f() { var e = s("CLASS_REF"); var r = T(); while (g(h())) { r += T() } e.value = r; e.end = n; return e } function c() { var e = s("ID_REF"); var r = T(); while (O(h())) { r += T() } e.value = r; e.end = n; return e } function p() { var e = s("IDENTIFIER"); var r = T(); while (b(h()) || A(h())) { r += T() } e.value = r; e.end = n; return e } function m() { var e = s("NUMBER"); var r = T(); while (w(h())) { r += T() } if (h() === ".") { r += T() } while (w(h())) { r += T() } e.value = r; e.end = n; return e } function v() { var e = T(); while (h() && k[e + h()]) { e += T() } var r = u(k[e], e); r.value = e; r.end = n; return r } function d() { var e = s("STRING"); var r = T(); var t = ""; while (h() && h() !== r) { if (h() === "\\") { T() } t += T() } if (h() !== r) { throw Error("Unterminated string at " + N(e)) } else { T() } e.value = t; e.end = n; return e } function h() { return r.charAt(n) } function E() { return r.charAt(n + 1) } function T() { o = h(); n++; a++; return o } function y() { return b(o) || w(o) || o === ")" || o === "}" || o === "]" } function x() { var e = s("WHITESPACE"); var r = ""; while (h() && q(h())) { if (I(h())) { a = 0; i++ } r += T() } e.value = r; e.end = n; return e } } return { tokenize: e, makeTokensObject: C } }(); var L = function () { var u = {}; var o = {}; var s = {}; var a = []; var l = []; function i(e, r, t) { var n = u[e]; if (n) return n(L, C, r, t) } function e(e, r, t, n) { var a = i(e, r, n); return a || v(r, t || "Expected " + e.autocapitalize) } function f(e, r) { for (var t = 0; t < e.length; t++) { var n = e[t]; var a = i(n, r); if (a) { return a } } } function t(e, r) { u[e] = r } function r(e, a) { var i = e + "Command"; var r = function (e, r, t) { var n = a(e, r, t); if (n) { n.type = i; n.execute = function (e) { return r.unifiedExec(this, e) }; return n } }; u[i] = r; o[e] = r } function n(a, i) { var o = a + "Feature"; var e = function (e, r, t) { var n = i(e, r, t); if (n) { n.keyword = a; n.type = o; return n } }; u[o] = e; s[a] = e } function c(e, r) { a.push(e); t(e, r) } function p(e, r) { l.push(e); t(e, r) } t("feature", function (e, r, t) { var n = s[t.currentToken().value]; if (n) { return n(e, r, t) } }); t("command", function (e, r, t) { var n = o[t.currentToken().value]; if (n) { return n(e, r, t) } }); t("commandList", function (e, r, t) { var n = e.parseElement("command", t); if (n) { t.matchToken("then"); n.next = e.parseElement("commandList", t); return n } }); t("leaf", function (e, r, t) { var n = f(a, t); if (n == null) { return i("symbol", t) } else { return n } }); t("indirectExpression", function (e, r, t, n) { for (var a = 0; a < l.length; a++) { var i = l[a]; var o = e.parseElement(i, t, n); if (o) { return o } } return n }); t("primaryExpression", function (e, r, t) { var n = e.parseElement("leaf", t); if (n) { return e.parseElement("indirectExpression", t, n) } e.raiseParseError(t, "Unexpected value: " + t.currentToken().value) }); function m(e) { var r = e.currentToken(); var t = e.source; var n = t.split("\n"); var a = r ? r.line - 1 : n.length - 1; var i = n[a]; var o = r ? r.column : i.length - 1; return i + "\n" + " ".repeat(o) + "^^\n\n" } function v(e, r) { r = (r || "Unexpected Token : " + e.currentToken().value) + "\n\n" + m(e); var t = new Error(r); t.tokens = e; throw t } function d(e) { return i("hyperscript", e) } function h(e, r) { if (e) { e.parent = r; h(e.next, r) } } function E(e) { if (e.value == "end" || e.value == "then" || o[e.value] || s[e.value] || e.type == "EOF") { return true } } return { setParent: h, requireElement: e, parseElement: i, commandBoundary: E, parseAnyOf: f, parseHyperScript: d, raiseParseError: v, addGrammarElement: t, addCommand: r, addFeature: n, addLeafExpression: c, addIndirectExpression: p } }(); var C = function () { function t(e, r) { var t = e.matches || e.matchesSelector || e.msMatchesSelector || e.mozMatchesSelector || e.webkitMatchesSelector || e.oMatchesSelector; return t && t.call(e, r) } function i(e, r) { var t; if (window.CustomEvent && typeof window.CustomEvent === "function") { t = new CustomEvent(e, { bubbles: true, cancelable: true, detail: r }) } else { t = document.createEvent("CustomEvent"); t.initCustomEvent(e, true, true, r) } return t } function o(e, r, t) { var t = t || {}; t["sentBy"] = e; var n = i(r, t); var a = e.dispatchEvent(n); return a } function u(e) { return Array.isArray(e) || e instanceof NodeList } function a(e, r) { if (e == null) { } else if (u(e)) { for (var t = 0; t < e.length; t++) { r(e[t]) } } else { r(e) } } var s = { array_sentinel: true }; function c(e) { var r = []; for (var t = 0; t < e.length; t++) { var n = e[t]; if (Array.isArray(n)) { r.push(s); for (var a = 0; a < n.length; a++) { r.push(n[a]) } r.push(s) } else { r.push(n) } } return r } function p(e) { var r = []; for (var t = 0; t < e.length; t++) { var n = e[t]; if (n === s) { n = e[++t]; var a = []; r.push(a); while (n !== s) { a.push(n); n = e[++t] } } else { r.push(n) } } return r } function m(e) { for (var r = 0; r < e.length; r++) { var t = e[r]; if (t.asyncWrapper) { e[r] = t.value } if (Array.isArray(t)) { for (var n = 0; n < t.length; n++) { var a = t[n]; if (a.asyncWrapper) { t[n] = a.value } } } } } var n = { halt_flag: true }; function l(e, r) { while (true) { var t = f(e, r); if (t == null) { console.error(e, " did not return a next element to execute! context: ", r); return } else if (t.then) { t.then(function (e) { l(e, r) }).catch(function (e) { if (r.meta && r.meta.reject) { r.meta.reject(e) } else { } }); return } else if (t === n) { return } else { e = t } } } function f(a, r) { var e = false; var i = false; var o = [r]; if (a.args) { for (var t = 0; t < a.args.length; t++) { var n = a.args[t]; if (n == null) { o.push(null) } else if (Array.isArray(n)) { var u = []; for (var s = 0; s < n.length; s++) { var l = n[s]; var f = l.evaluate(r); if (f) { if (f.then) { e = true } else if (f.asyncWrapper) { i = true } } u.push(f) } o.push(u) } else if (n.evaluate) { var f = n.evaluate(r); if (f) { if (f.then) { e = true } else if (f.asyncWrapper) { i = true } } o.push(f) } else { o.push(n) } } } if (e) { return new Promise(function (t, n) { var e = c(o); Promise.all(e).then(function (e) { e = p(e); if (i) { m(e) } try { var r = a.op.apply(a, e); t(r) } catch (e) { n(e) } }).catch(function (e) { if (r.meta && r.meta.reject) { r.meta.reject(e) } else { } }) }) } else { if (i) { m(o) } try { return a.op.apply(a, o) } catch (e) { if (r.meta && r.meta.reject) { r.meta.reject(e) } else { throw e } } } } var e = null; function v() { if (e == null) { e = _hyperscript.config.attributes.replace(/ /g, "").split(",") } return e } function d(e) { for (var r = 0; r < v().length; r++) { var t = v()[r]; if (e.hasAttribute && e.hasAttribute(t)) { return e.getAttribute(t) } } if (e.type === "text/hyperscript") { return e.innerText } return null } function h(e, r, t) { var n = { meta: { parser: L, lexer: R, runtime: C, root: e, iterators: e }, me: r, event: t, detail: t ? t.detail : null, body: "document" in A ? document.body : null }; n.meta.ctx = n; return n } function r(e, n) { a(e.onFeatures, function (t) { a(t.elsewhere ? [document] : t.from ? t.from.evaluate({}) : [n], function (e) { e.addEventListener(t.on.evaluate(), function (e) { if (t.elsewhere && n.contains(e.target)) return; var r = h(t, n, e); t.execute(r) }) }) }) } function E() { return v().map(function (e) { return "[" + e + "]" }).join(", ") } function T(e, r) { return Object.prototype.toString.call(e) === "[object " + r + "]" } function y(e, r, t) { if (T(r, "Object")) { var n = e; var a = r; var i = "expression" } else if (T(r, "String")) { var n = r; var i = e; var a = t } else { var n = e; var a = {}; var i = "expression" } a = a || {}; var o = L.parseElement(i, R.tokenize(n)); return o.evaluate ? o.evaluate(a) : o.execute(a) } function x(e) { var r = C.getScriptSelector(); if (t(e, r)) { k(e) } if (e.querySelectorAll) { a(e.querySelectorAll(r), function (e) { k(e) }) } if (e.type === "text/hyperscript") { k(e, document.body) } if (e.querySelectorAll) { a(e.querySelectorAll("[type='text/hyperscript']"), function (e) { k(e, document.body) }) } } function k(r, e) { var t = g(r); if (!t.initialized) { var n = d(r); if (n) { try { t.initialized = true; t.script = n; var a = R.tokenize(n); var i = L.parseHyperScript(a); C.applyEventListeners(i, e || r); setTimeout(function () { o(e || r, "load") }, 1) } catch (e) { console.error("hyperscript errors were found on the following element:", r, "\n\n", e.message, e.stack) } } } } function g(e) { var r = "hyperscript-internal-data"; var t = e[r]; if (!t) { t = e[r] = {} } return t } function O(e, r, t) { if (e == null && t) { return e } var n = Object.prototype.toString.call(e).slice(8, -1); var a = e && n === r; if (a) { return e } else { throw new Error("Typecheck failed!  Expected: " + r + ", Found: " + n) } } function q(e, r) { if (e === "me" || e === "my") { return r["me"] } if (e === "it" || e === "its") { return r["it"] } else { if (r.meta && r.meta.context) { var t = r.meta.context[e]; if (typeof t !== "undefined") { return t } } var n = r[e]; if (typeof n !== "undefined") { return n } else { return A[e] } } } function N(e) { if (e) { if (e.resolveNext) { return e.resolveNext() } else if (e.next) { return e.next } else { return N(e.parent) } } } function I(e, r) { if (e != null) { var t = e[r]; if (typeof t !== "undefined") { return t } else { if (u(e)) { if (r === "first") { return e[0] } else if (r === "last") { return e[e.length - 1] } else if (r === "random") { return e[Math.floor(e.length * Math.random())] } else { var n = []; for (var a = 0; a < e.length; a++) { var i = e[a]; var o = i[r]; if (o) { n.push(o) } } return n } } } } } function w(e, r, t) { var n = A; while (e.length > 0) { var a = e.shift(); var i = n[a]; if (i == null) { i = {}; n[a] = i } n = i } n[r] = t } var b = "document" in A ? document.currentScript.src : null; return { typeCheck: O, forEach: a, triggerEvent: o, matchesSelector: t, getScript: d, applyEventListeners: r, processNode: x, evaluate: y, getScriptSelector: E, resolveSymbol: q, makeContext: h, findNext: N, unifiedEval: f, unifiedExec: l, resolveProperty: I, assignToNamespace: w, hyperscriptUrl: b, HALT: n } }(); { L.addLeafExpression("parenthesized", function (e, r, t) { if (t.matchOpToken("(")) { var n = e.requireElement("expression", t); t.requireOpToken(")"); return { type: "parenthesized", expr: n, evaluate: function (e) { return n.evaluate(e) } } } }); L.addLeafExpression("string", function (e, r, t) { var n = t.matchTokenType("STRING"); if (n) { return { type: "string", token: n, evaluate: function (e) { return n.value } } } }); L.addGrammarElement("nakedString", function (e, r, t) { if (t.hasMore()) { var n = t.consumeUntilWhitespace(); t.matchTokenType("WHITESPACE"); return { type: "nakedString", tokens: n, evaluate: function (e) { return n.map(function (e) { return e.value }).join("") } } } }); L.addLeafExpression("number", function (e, r, t) { var n = t.matchTokenType("NUMBER"); if (n) { var a = n; var i = parseFloat(n.value); return { type: "number", value: i, numberToken: a, evaluate: function () { return i } } } }); L.addLeafExpression("idRef", function (e, r, t) { var n = t.matchTokenType("ID_REF"); if (n) { return { type: "idRef", value: n.value.substr(1), evaluate: function (e) { return document.getElementById(this.value) } } } }); L.addLeafExpression("classRef", function (e, r, t) { var n = t.matchTokenType("CLASS_REF"); if (n) { return { type: "classRef", value: n.value, className: function () { return this.value.substr(1) }, evaluate: function () { return document.querySelectorAll(this.value) } } } }); L.addGrammarElement("attributeRef", function (e, r, t) { if (t.matchOpToken("[")) { var n = t.matchTokenType("IDENTIFIER"); var a = null; if (t.matchOpToken("=")) { a = e.requireElement("expression", t) } t.requireOpToken("]"); return { type: "attribute_expression", name: n.value, value: a, args: [a], op: function (e, r) { if (this.value) { return { name: this.name, value: r } } else { return { name: this.name } } }, evaluate: function (e) { return r.unifiedEval(this, e) } } } }); L.addLeafExpression("objectLiteral", function (e, r, t) { if (t.matchOpToken("{")) { var i = []; var n = []; if (!t.matchOpToken("}")) { do { var a = t.requireTokenType("IDENTIFIER"); t.requireOpToken(":"); var o = e.requireElement("expression", t); n.push(o); i.push({ name: a, value: o }) } while (t.matchOpToken(",")); t.requireOpToken("}") } return { type: "objectLiteral", fields: i, args: [n], op: function (e, r) { var t = {}; for (var n = 0; n < r.length; n++) { var a = i[n]; t[a.name.value] = r[n] } return t }, evaluate: function (e) { return r.unifiedEval(this, e) } } } }); L.addGrammarElement("namedArgumentList", function (e, r, t) { if (t.matchOpToken("(")) { var i = []; var n = []; if (!t.matchOpToken(")")) { do { var a = t.requireTokenType("IDENTIFIER"); t.requireOpToken(":"); var o = e.requireElement("expression", t); n.push(o); i.push({ name: a, value: o }) } while (t.matchOpToken(",")); t.requireOpToken(")") } return { type: "namedArgumentList", fields: i, args: [n], op: function (e, r) { var t = { _namedArgList_: true }; for (var n = 0; n < r.length; n++) { var a = i[n]; t[a.name.value] = r[n] } return t }, evaluate: function (e) { return r.unifiedEval(this, e) } } } }); L.addGrammarElement("symbol", function (e, r, t) { var n = t.matchTokenType("IDENTIFIER"); if (n) { return { type: "symbol", name: n.value, evaluate: function (e) { return r.resolveSymbol(n.value, e) } } } }); L.addGrammarElement("implicitMeTarget", function (e, r, t) { return { type: "implicitMeTarget", evaluate: function (e) { return e.me } } }); L.addGrammarElement("implicitAllTarget", function (e, r, t) { return { type: "implicitAllTarget", evaluate: function (e) { return document.querySelectorAll("*") } } }); L.addLeafExpression("boolean", function (e, r, t) { var n = t.matchToken("true") || t.matchToken("false"); if (n) { return { type: "boolean", evaluate: function (e) { return n.value === "true" } } } }); L.addLeafExpression("null", function (e, r, t) { if (t.matchToken("null")) { return { type: "null", evaluate: function (e) { return null } } } }); L.addLeafExpression("arrayLiteral", function (e, r, t) { if (t.matchOpToken("[")) { var n = []; if (!t.matchOpToken("]")) { do { var a = e.requireElement("expression", t); n.push(a) } while (t.matchOpToken(",")); t.requireOpToken("]") } return { type: "arrayLiteral", values: n, args: [n], op: function (e, r) { return r }, evaluate: function (e) { return r.unifiedEval(this, e) } } } }); L.addLeafExpression("blockLiteral", function (e, r, t) { if (t.matchOpToken("\\")) { var n = []; var a = t.matchTokenType("IDENTIFIER"); if (a) { n.push(a); while (t.matchOpToken(",")) { n.push(t.requireTokenType("IDENTIFIER")) } } t.requireOpToken("-"); t.requireOpToken(">"); var i = e.requireElement("expression", t); return { type: "blockLiteral", args: n, expr: i, evaluate: function (r) { var e = function () { for (var e = 0; e < n.length; e++) { r[n[e].value] = arguments[e] } return i.evaluate(r) }; return e } } } }); L.addGrammarElement("timeExpression", function (e, r, t) { var n = e.requireElement("expression", t); var a = 1; if (t.matchToken("s") || t.matchToken("seconds")) { a = 1e3 } else if (t.matchToken("ms") || t.matchToken("milliseconds")) { } return { type: "timeExpression", time: n, factor: a, args: [n], op: function (e, r) { return r * this.factor }, evaluate: function (e) { return r.unifiedEval(this, e) } } }); L.addIndirectExpression("propertyAccess", function (e, t, r, n) { if (r.matchOpToken(".")) { var a = r.requireTokenType("IDENTIFIER"); var i = { type: "propertyAccess", root: n, prop: a, args: [n], op: function (e, r) { return t.resolveProperty(r, a.value) }, evaluate: function (e) { return t.unifiedEval(this, e) } }; return e.parseElement("indirectExpression", r, i) } }); L.addIndirectExpression("functionCall", function (e, r, t, a) { if (t.matchOpToken("(")) { var n = []; if (!t.matchOpToken(")")) { do { n.push(e.requireElement("expression", t)) } while (t.matchOpToken(",")); t.requireOpToken(")") } if (a.root) { var i = { type: "functionCall", root: a, argExressions: n, args: [a.root, n], op: function (e, r, t) { var n = r[a.prop.value]; return n.apply(r, t) }, evaluate: function (e) { return r.unifiedEval(this, e) } } } else { var i = { type: "functionCall", root: a, argExressions: n, args: [a, n], op: function (e, r, t) { var n = r.apply(null, t); return n }, evaluate: function (e) { return r.unifiedEval(this, e) } } } return e.parseElement("indirectExpression", t, i) } }); L.addIndirectExpression("arrayIndex", function (e, r, t, n) { if (t.matchOpToken("[")) { var a = e.requireElement("expression", t); t.requireOpToken("]"); var i = { type: "arrayIndex", root: n, index: a, args: [n, a], op: function (e, r, t) { return r[t] }, evaluate: function (e) { return C.unifiedEval(this, e) } }; return L.parseElement("indirectExpression", t, i) } }); L.addGrammarElement("postfixExpression", function (e, t, r) { var n = e.parseElement("primaryExpression", r); if (r.matchOpToken(":")) { var a = r.requireTokenType("IDENTIFIER"); var i = !r.matchOpToken("!"); return { type: "typeCheck", typeName: a, root: n, nullOk: i, args: [n], op: function (e, r) { return t.typeCheck(r, this.typeName.value, this.nullOk) }, evaluate: function (e) { return t.unifiedEval(this, e) } } } else { return n } }); L.addGrammarElement("logicalNot", function (e, r, t) { if (t.matchToken("not")) { var n = e.requireElement("unaryExpression", t); return { type: "logicalNot", root: n, args: [n], op: function (e, r) { return !r }, evaluate: function (e) { return r.unifiedEval(this, e) } } } }); L.addGrammarElement("noExpression", function (e, r, t) { if (t.matchToken("no")) { var n = e.requireElement("unaryExpression", t); return { type: "noExpression", root: n, args: [n], op: function (e, r) { return r == null }, evaluate: function (e) { return r.unifiedEval(this, e) } } } }); L.addGrammarElement("negativeNumber", function (e, r, t) { if (t.matchOpToken("-")) { var n = e.requireElement("unaryExpression", t); return { type: "negativeNumber", root: n, args: [n], op: function (e, r) { return -1 * r }, evaluate: function (e) { return r.unifiedEval(this, e) } } } }); L.addGrammarElement("unaryExpression", function (e, r, t) { return e.parseAnyOf(["logicalNot", "noExpression", "negativeNumber", "postfixExpression"], t) }); L.addGrammarElement("mathOperator", function (e, r, t) { var n = e.parseElement("unaryExpression", t); var a, i = null; a = t.matchAnyOpToken("+", "-", "*", "/", "%"); while (a) { i = i || a; var o = a.value; if (i.value !== o) { e.raiseParseError(t, "You must parenthesize math operations with different operators") } var u = e.parseElement("unaryExpression", t); n = { type: "mathOperator", lhs: n, rhs: u, operator: o, args: [n, u], op: function (e, r, t) { if (this.operator === "+") { return r + t } else if (this.operator === "-") { return r - t } else if (this.operator === "*") { return r * t } else if (this.operator === "/") { return r / t } else if (this.operator === "%") { return r % t } }, evaluate: function (e) { return r.unifiedEval(this, e) } }; a = t.matchAnyOpToken("+", "-", "*", "/", "%") } return n }); L.addGrammarElement("mathExpression", function (e, r, t) { return e.parseAnyOf(["mathOperator", "unaryExpression"], t) }); L.addGrammarElement("comparisonOperator", function (e, r, t) { var n = e.parseElement("mathExpression", t); var a = t.matchAnyOpToken("<", ">", "<=", ">=", "==", "===", "!=", "!=="); var i = a ? a.value : null; if (i == null && t.matchToken("is")) { if (t.matchToken("not")) { i = "!=" } else { i = "==" } } if (i) { var o = e.requireElement("mathExpression", t); n = { type: "comparisonOperator", operator: i, lhs: n, rhs: o, args: [n, o], op: function (e, r, t) { if (this.operator === "<") { return r < t } else if (this.operator === ">") { return r > t } else if (this.operator === "<=") { return r <= t } else if (this.operator === ">=") { return r >= t } else if (this.operator === "==") { return r == t } else if (this.operator === "===") { return r === t } else if (this.operator === "!=") { return r != t } else if (this.operator === "!==") { return r !== t } }, evaluate: function (e) { return r.unifiedEval(this, e) } } } return n }); L.addGrammarElement("comparisonExpression", function (e, r, t) { return e.parseAnyOf(["comparisonOperator", "mathExpression"], t) }); L.addGrammarElement("logicalOperator", function (e, r, t) { var n = e.parseElement("comparisonExpression", t); var a, i = null; a = t.matchToken("and") || t.matchToken("or"); while (a) { i = i || a; if (i.value !== a.value) { e.raiseParseError(t, "You must parenthesize logical operations with different operators") } var o = e.requireElement("comparisonExpression", t); n = { type: "logicalOperator", operator: a.value, lhs: n, rhs: o, args: [n, o], op: function (e, r, t) { if (this.operator === "and") { return r && t } else { return r || t } }, evaluate: function (e) { return r.unifiedEval(this, e) } }; a = t.matchToken("and") || t.matchToken("or") } return n }); L.addGrammarElement("logicalExpression", function (e, r, t) { return e.parseAnyOf(["logicalOperator", "mathExpression"], t) }); L.addGrammarElement("asyncExpression", function (e, r, t) { if (t.matchToken("async")) { var n = e.requireElement("logicalExpression", t); var a = { type: "asyncExpression", value: n, evaluate: function (e) { return { asyncWrapper: true, value: this.value.evaluate(e) } } }; return a } else { return e.parseElement("logicalExpression", t) } }); L.addGrammarElement("expression", function (e, r, t) { return e.parseElement("asyncExpression", t) }); L.addGrammarElement("target", function (e, r, t) { var n = L.parseElement("expression", t); if (n.type === "symbol" || n.type === "idRef" || n.type === "classRef" || n.type === "propertyAccess") { return n } else { L.raiseParseError(t, "A target expression must be writable") } return n }); L.addGrammarElement("hyperscript", function (e, r, t) { var n = []; var a = []; if (t.hasMore()) { do { var i = e.requireElement("feature", t); if (i.type === "onFeature") { n.push(i) } else if (i.type === "defFeature") { i.execute(); a.push(i) } else if (i.type === "jsFeature") { i.execute() } else { if ("execute" in i) { i.execute() } } var o = i.type === "onFeature" && t.currentToken() && t.currentToken().value === "on" } while ((o || t.matchToken("end")) && t.hasMore()); if (t.hasMore()) { e.raiseParseError(t) } } return { type: "hyperscript", onFeatures: n, functions: a, execute: function () { } } }); L.addFeature("on", function (e, n, r) { if (r.matchToken("on")) { var t = false; if (r.matchToken("every")) { t = true } var a = e.requireElement("dotOrColonPath", r, "Expected event name"); var i = []; if (r.matchOpToken("(")) { do { i.push(r.requireTokenType("IDENTIFIER")) } while (r.matchOpToken(",")); r.requireOpToken(")") } var o = null; if (r.matchOpToken("[")) { o = e.requireElement("expression", r); r.requireOpToken("]") } var u = null; var s = false; if (r.matchToken("from")) { if (r.matchToken("elsewhere")) { s = true } else { u = e.parseElement("target", r); if (!u) { e.raiseParseError('Expected either target value or "elsewhere".', r) } } } if (u === null && s === false && r.matchToken("elsewhere")) { s = true } var l = e.requireElement("commandList", r); var f = { type: "implicitReturn", op: function (e) { e.meta.resolve(); return n.HALT }, execute: function (e) { } }; if (l) { var c = l; while (c.next) { c = c.next } c.next = f } else { l = f } var p = { args: i, on: a, every: t, from: u, elsewhere: s, filter: o, start: l, executing: false, execCount: 0, execute: function (r) { if (this.executing && this.every === false) { return } this.execCount++; this.executing = true; n.forEach(i, function (e) { r[e.value] = r.event[e.value] || (r.event.detail ? r.event.detail[e.value] : null) }); if (o) { var e = r.meta.context; r.meta.context = r.event; try { var t = o.evaluate(r); if (t) { } else { this.executing = false; return } } finally { r.meta.context = e } } r.meta.resolve = function () { p.executing = false }; r.meta.reject = function (e) { console.error(e); n.triggerEvent(r.me, "exception", { error: e }); p.executing = false }; l.execute(r) } }; e.setParent(l, p); return p } }); L.addFeature("def", function (e, l, r) { if (r.matchToken("def")) { var t = e.requireElement("dotOrColonPath", r); var n = t.evaluate(); var a = n.split("."); var i = a.pop(); var f = []; if (r.matchOpToken("(")) { if (r.matchOpToken(")")) { } else { do { f.push(r.requireTokenType("IDENTIFIER")) } while (r.matchOpToken(",")); r.requireOpToken(")") } } var c = e.parseElement("commandList", r); var o = { name: i, args: f, start: c, execute: function (e) { l.assignToNamespace(a, i, function () { var e = "document" in A ? document.body : null; var r = "document" in A ? document.body : A; var t = l.makeContext(e, r, null); for (var n = 0; n < arguments.length; n++) { var a = arguments[n]; var i = f[n]; if (i) { t[i.value] = a } } var o, u = null; var s = new Promise(function (e, r) { o = e; u = r }); c.execute(t); if (t.meta.returned) { return t.meta.returnValue } else { t.meta.resolve = o; t.meta.reject = u; return s } }) } }; var u = { type: "implicitReturn", op: function (e) { e.meta.returned = true; if (e.meta.resolve) { e.meta.resolve() } return l.HALT }, execute: function (e) { } }; if (c) { var s = c; while (s.next) { s = s.next } s.next = u } else { o.start = u } e.setParent(c, o); return o } }); L.addFeature("worker", function (e, r, t) { if (t.matchToken("worker")) { e.raiseParseError(t, "In order to use the 'worker' feature, include " + "the _hyperscript worker plugin. See " + "https://hyperscript.org/features/worker/ for " + "more info.") } }); L.addGrammarElement("jsBody", function (e, r, t) { var n = t.currentToken().start; var a = t.currentToken(); var i = []; var o = ""; var u = false; while (t.hasMore()) { a = t.consumeToken(); var s = t.currentToken(true); if (s.type === "IDENTIFIER" && s.value === "end") { break } if (u) { if (a.type === "IDENTIFIER" || a.type === "NUMBER") { o += a.value } else { if (o !== "") i.push(o); o = ""; u = false } } else if (a.type === "IDENTIFIER" && a.value === "function") { u = true } } var l = a.end + 1; return { type: "jsBody", exposedFunctionNames: i, jsSource: t.source.substring(n, l) } }); L.addFeature("js", function (e, r, t) { if (t.matchToken("js")) { var n = e.parseElement("jsBody", t); var a = n.jsSource + "\nreturn { " + n.exposedFunctionNames.map(function (e) { return e + ":" + e }).join(",") + " } "; var i = new Function(a); return { jsSource: a, function: i, exposedFunctionNames: n.exposedFunctionNames, execute: function () { o(A, i()) } } } }); L.addCommand("js", function (e, n, r) { if (r.matchToken("js")) { var a = []; if (r.matchOpToken("(")) { if (r.matchOpToken(")")) { } else { do { var t = r.requireTokenType("IDENTIFIER"); a.push(t.value) } while (r.matchOpToken(",")); r.requireOpToken(")") } } var i = e.parseElement("jsBody", r); r.matchToken("end"); var o = u(Function, a.concat([i.jsSource])); return { jsSource: i.jsSource, function: o, inputs: a, op: function (t) { var r = []; a.forEach(function (e) { r.push(n.resolveSymbol(e, t)) }); var e = o.apply(A, r); if (e && typeof e.then === "function") { return Promise(function (r) { e.then(function (e) { t.it = e; r(n.findNext(this)) }) }) } else { t.it = e; return n.findNext(this) } } } } }); L.addCommand("add", function (e, n, r) { if (r.matchToken("add")) { var t = e.parseElement("classRef", r); var a = null; if (t == null) { a = e.parseElement("attributeRef", r); if (a == null) { e.raiseParseError(r, "Expected either a class reference or attribute expression") } } if (r.matchToken("to")) { var i = e.requireElement("target", r) } else { var i = e.parseElement("implicitMeTarget") } if (t) { var o = { classRef: t, attributeRef: a, to: i, args: [i], op: function (e, r) { n.forEach(r, function (e) { e.classList.add(t.className()) }); return n.findNext(this) } } } else { var o = { type: "addCmd", classRef: t, attributeRef: a, to: i, args: [i, a], op: function (e, r, t) { n.forEach(r, function (e) { e.setAttribute(t.name, t.value) }); return n.findNext(o, e) }, execute: function (e) { return n.unifiedExec(this, e) } } } return o } }); L.addCommand("remove", function (e, t, r) { if (r.matchToken("remove")) { var n = e.parseElement("classRef", r); var a = null; var i = null; if (n == null) { a = e.parseElement("attributeRef", r); if (a == null) { i = e.parseElement("expression", r); if (i == null) { e.raiseParseError(r, "Expected either a class reference, attribute expression or value expression") } } } if (r.matchToken("from")) { var o = e.requireElement("target", r) } else { var o = e.requireElement("implicitMeTarget") } if (i) { var u = { classRef: n, attributeRef: a, elementExpr: i, from: o, args: [i], op: function (e, r) { t.forEach(r, function (e) { e.parentElement.removeChild(e) }); return t.findNext(this) } } } else { var u = { classRef: n, attributeRef: a, elementExpr: i, from: o, args: [o], op: function (e, r) { if (this.classRef) { t.forEach(r, function (e) { e.classList.remove(n.className()) }) } else { t.forEach(r, function (e) { e.removeAttribute(a.name) }) } return t.findNext(this) } } } return u } }); L.addCommand("toggle", function (e, u, r) { if (r.matchToken("toggle")) { var t = e.parseElement("classRef", r); var n = null; if (t == null) { n = e.parseElement("attributeRef", r); if (n == null) { e.raiseParseError(r, "Expected either a class reference or attribute expression") } } if (r.matchToken("on")) { var a = e.requireElement("target", r) } else { var a = e.requireElement("implicitMeTarget") } if (r.matchToken("for")) { var i = e.requireElement("timeExpression", r) } else if (r.matchToken("until")) { var o = e.requireElement("dotOrColonPath", r, "Expected event name"); if (r.matchToken("from")) { var s = e.requireElement("expression", r) } } var l = { classRef: t, attributeRef: n, on: a, time: i, evt: o, from: s, toggle: function (e, r) { if (this.classRef) { u.forEach(e, function (e) { e.classList.toggle(t.className()) }) } else { u.forEach(e, function (e) { if (e.hasAttribute(n.name)) { e.removeAttribute(n.name) } else { e.setAttribute(n.name, r) } }) } }, args: [a, n ? n.value : null, i, o, s], op: function (t, n, a, r, i, o) { if (r) { return new Promise(function (e) { l.toggle(n, a); setTimeout(function () { l.toggle(n, a); e(u.findNext(l)) }, r) }) } else if (i) { return new Promise(function (e) { var r = o || t.me; r.addEventListener(i, function () { l.toggle(n, a); e(u.findNext(l)) }, { once: true }); l.toggle(n, a) }) } else { this.toggle(n, a); return u.findNext(l) } } }; return l } }); var s = { display: function (e, r, t) { if (t) { r.style.display = t } else if (e === "hide") { r.style.display = "none" } else { r.style.display = "block" } }, visibility: function (e, r, t) { if (t) { r.style.visibility = t } else if (e === "hide") { r.style.visibility = "hidden" } else { r.style.visibility = "visible" } }, opacity: function (e, r, t) { if (t) { r.style.opacity = t } else if (e === "hide") { r.style.opacity = "0" } else { r.style.opacity = "1" } } }; var l = function (e, r, t) { var n; var a = t.currentToken(); if (a.value === "with" || e.commandBoundary(a)) { n = e.parseElement("implicitMeTarget", t) } else { n = e.parseElement("target", t) } return n }; var f = function (e, r, t) { var n = _hyperscript.config.defaultHideShowStrategy; var a = s; if (_hyperscript.config.hideShowStrategies) { a = o(a, _hyperscript.config.hideShowStrategies) } t = t || n || "display"; var i = a[t]; if (i == null) { e.raiseParseError(r, "Unknown show/hide strategy : " + t) } return i }; L.addCommand("hide", function (e, t, r) { if (r.matchToken("hide")) { var n = l(e, t, r); var a = null; if (r.matchToken("with")) { a = r.requireTokenType("IDENTIFIER").value } var i = f(e, r, a); return { target: n, args: [n], op: function (e, r) { t.forEach(r, function (e) { i("hide", e) }); return t.findNext(this) } } } }); L.addCommand("show", function (e, t, r) { if (r.matchToken("show")) { var n = l(e, t, r); var a = null; if (r.matchToken("with")) { a = r.requireTokenType("IDENTIFIER").value } var i = null; if (r.matchOpToken(":")) { var o = r.consumeUntilWhitespace(); r.matchTokenType("WHITESPACE"); i = o.map(function (e) { return e.value }).join("") } var u = f(e, r, a); return { target: n, args: [n], op: function (e, r) { t.forEach(r, function (e) { u("show", e, i) }); return t.findNext(this) } } } }); L.addCommand("wait", function (e, a, r) { if (r.matchToken("wait")) { if (r.matchToken("for")) { r.matchToken("a"); var t = L.requireElement("dotOrColonPath", r, "Expected event name"); if (r.matchToken("from")) { var n = e.requireElement("expression", r) } var i = { event: t, on: n, args: [t, n], op: function (e, t, r) { var n = r ? r : e.me; return new Promise(function (e) { var r = function () { e(a.findNext(i)) }; n.addEventListener(t, r, { once: true }) }) } } } else { var o = L.requireElement("timeExpression", r); var i = { type: "waitCmd", time: o, args: [o], op: function (e, r) { return new Promise(function (e) { setTimeout(function () { e(a.findNext(i)) }, r) }) }, execute: function (e) { return a.unifiedExec(this, e) } } } return i } }); L.addGrammarElement("dotOrColonPath", function (e, r, t) { var n = t.matchTokenType("IDENTIFIER"); if (n) { var a = [n.value]; var i = t.matchOpToken(".") || t.matchOpToken(":"); if (i) { do { a.push(t.requireTokenType("IDENTIFIER").value) } while (t.matchOpToken(i.value)) } return { type: "dotOrColonPath", path: a, evaluate: function () { return a.join(i ? i.value : "") } } } }); L.addCommand("send", function (e, a, r) { if (r.matchToken("send")) { var t = e.requireElement("dotOrColonPath", r); var n = e.parseElement("namedArgumentList", r); if (r.matchToken("to")) { var i = e.requireElement("target", r) } else { var i = e.requireElement("implicitMeTarget") } var o = { eventName: t, details: n, to: i, args: [i, t, n], op: function (e, r, t, n) { a.forEach(r, function (e) { a.triggerEvent(e, t, n ? n : {}) }); return a.findNext(o) } }; return o } }); L.addCommand("return", function (e, n, r) { if (r.matchToken("return")) { var t = e.requireElement("expression", r); var a = { value: t, args: [t], op: function (e, r) { var t = e.meta.resolve; e.meta.returned = true; if (t) { if (r) { t(r) } else { t() } } else { e.meta.returned = true; e.meta.returnValue = r } return n.HALT } }; return a } }); L.addCommand("trigger", function (e, n, r) { if (r.matchToken("trigger")) { var t = e.requireElement("dotOrColonPath", r); var a = e.parseElement("namedArgumentList", r); var i = { eventName: t, details: a, args: [t, a], op: function (e, r, t) { n.triggerEvent(e.me, r, t ? t : {}); return n.findNext(i) } }; return i } }); L.addCommand("take", function (e, a, r) { if (r.matchToken("take")) { var t = r.requireTokenType(r, "CLASS_REF"); if (r.matchToken("from")) { var n = e.requireElement("target", r) } else { var n = e.requireElement("implicitAllTarget") } if (r.matchToken("for")) { var i = e.requireElement("target", r) } else { var i = e.requireElement("implicitMeTarget") } var o = { classRef: t, from: n, forElt: i, args: [n, i], op: function (e, r, t) { var n = this.classRef.value.substr(1); a.forEach(r, function (e) { e.classList.remove(n) }); a.forEach(t, function (e) { e.classList.add(n) }); return a.findNext(this) } }; return o } }); L.addCommand("log", function (e, n, r) { if (r.matchToken("log")) { var t = [e.parseElement("expression", r)]; while (r.matchOpToken(",")) { t.push(e.requireElement("expression", r)) } if (r.matchToken("with")) { var a = e.requireElement("expression", r) } var i = { exprs: t, withExpr: a, args: [a, t], op: function (e, r, t) { if (r) { r.apply(null, t) } else { console.log.apply(null, t) } return n.findNext(this) } }; return i } }); L.addCommand("throw", function (e, n, r) { if (r.matchToken("throw")) { var t = e.requireElement("expression", r); var a = { expr: t, args: [t], op: function (e, r) { var t = e.meta && e.meta.reject; if (t) { t(r); return n.HALT } else { throw r } } }; return a } }); var n = function (e, t, r) { var n = e.requireElement("expression", r); var a = { expr: n, args: [n], op: function (e, r) { e.it = r; return t.findNext(a) } }; return a }; L.addCommand("call", function (e, r, t) { if (t.matchToken("call")) { return n(e, r, t) } }); L.addCommand("get", function (e, r, t) { if (t.matchToken("get")) { return n(e, r, t) } }); L.addCommand("put", function (e, n, r) { if (r.matchToken("put")) { var t = e.requireElement("expression", r); var a = r.matchToken("into") || r.matchToken("before") || r.matchToken("after"); if (a == null && r.matchToken("at")) { a = r.matchToken("start") || r.matchToken("end"); r.requireToken("of") } if (a == null) { e.raiseParseError(r, "Expected one of 'into', 'before', 'at start of', 'at end of', 'after'") } var i = e.requireElement("target", r); var o = a.value; var u = i.type === "symbol" && o === "into"; if (i.type !== "symbol" && o === "into" && i.root == null) { e.raiseParseError(r, "Can only put directly into symbols, not references") } var s = null; var l = null; if (u) { } else if (o === "into") { l = i.prop.value; s = i.root } else { s = i } var f = { target: i, operation: o, symbolWrite: u, value: t, args: [s, t], op: function (e, r, t) { if (u) { e[i.name] = t } else { if (o === "into") { n.forEach(r, function (e) { e[l] = t }) } else if (o === "before") { n.forEach(r, function (e) { e.insertAdjacentHTML("beforebegin", t) }) } else if (o === "start") { n.forEach(r, function (e) { e.insertAdjacentHTML("afterbegin", t) }) } else if (o === "end") { n.forEach(r, function (e) { e.insertAdjacentHTML("beforeend", t) }) } else if (o === "after") { n.forEach(r, function (e) { e.insertAdjacentHTML("afterend", t) }) } } return n.findNext(this) } }; return f } }); L.addCommand("set", function (e, n, r) { if (r.matchToken("set")) { var a = e.requireElement("target", r); r.requireToken("to"); var t = e.requireElement("expression", r); var i = a.type === "symbol"; if (a.type !== "symbol" && a.root == null) { e.raiseParseError(r, "Can only put directly into symbols, not references") } var o = null; var u = null; if (i) { } else { u = a.prop.value; o = a.root } var s = { target: a, symbolWrite: i, value: t, args: [o, t], op: function (e, r, t) { if (i) { e[a.name] = t } else { n.forEach(r, function (e) { e[u] = t }) } return n.findNext(this) } }; return s } }); L.addCommand("if", function (e, t, r) { if (r.matchToken("if")) { var n = e.requireElement("expression", r); r.matchToken("then"); var a = e.parseElement("commandList", r); if (r.matchToken("else")) { var i = e.parseElement("commandList", r) } if (r.hasMore()) { r.requireToken("end") } var o = { expr: n, trueBranch: a, falseBranch: i, args: [n], op: function (e, r) { if (r) { return a } else if (i) { return i } else { return t.findNext(this) } } }; e.setParent(a, o); e.setParent(i, o); return o } }); var a = function (e, r, a, t) { var n = r.currentToken(); if (r.matchToken("for") || t) { var i = r.requireTokenType("IDENTIFIER"); var o = i.value; r.requireToken("in"); var u = e.requireElement("expression", r) } else if (r.matchToken("in")) { var o = "it"; var u = e.requireElement("expression", r) } else if (r.matchToken("while")) { var s = e.requireElement("expression", r) } else if (r.matchToken("until")) { var l = true; if (r.matchToken("event")) { var f = L.requireElement("dotOrColonPath", r, "Expected event name"); if (r.matchToken("from")) { var c = e.requireElement("expression", r) } } else { var s = e.requireElement("expression", r) } } else if (r.matchTokenType("NUMBER")) { var p = parseFloat(n.value); r.requireToken("times") } else { r.matchToken("forever"); var m = true } if (r.matchToken("index")) { var i = r.requireTokenType("IDENTIFIER"); var v = i.value } var d = e.parseElement("commandList", r); if (r.hasMore()) { r.requireToken("end") } if (o == null) { o = "_implicit_repeat_" + n.start; var h = o } else { var h = o + "_" + n.start } var E = { identifier: o, indexIdentifier: v, slot: h, expression: u, forever: m, times: p, until: l, event: f, on: c, whileExpr: s, resolveNext: function () { return this }, loop: d, args: [s], op: function (e, r) { var t = e.meta.iterators[h]; var n = false; if (this.forever) { n = true } else if (this.until) { if (f) { n = e.meta.iterators[h].eventFired == false } else { n = r != true } } else if (r) { n = true } else if (p) { n = t.index < this.times } else { n = t.value !== null && t.index < t.value.length } if (n) { if (t.value) { e[o] = t.value[t.index]; e.it = t.value[t.index] } else { e.it = t.index } if (v) { e[v] = t.index } t.index++; return d } else { e.meta.iterators[h] = null; return a.findNext(this.parent) } } }; e.setParent(d, E); var T = { name: "repeatInit", args: [u, f, c], op: function (r, e, t, n) { r.meta.iterators[h] = { index: 0, value: e, eventFired: false }; if (f) { var a = n || r.me; a.addEventListener(t, function (e) { r.meta.iterators[h].eventFired = true }, { once: true }) } return E }, execute: function (e) { return a.unifiedExec(this, e) } }; e.setParent(E, T); return T }; L.addCommand("repeat", function (e, r, t) { if (t.matchToken("repeat")) { return a(e, t, r, false) } }); L.addCommand("for", function (e, r, t) { if (t.matchToken("for")) { return a(e, t, r, true) } }); L.addCommand("fetch", function (e, i, r) { if (r.matchToken("fetch")) { var t = e.parseElement("string", r); if (t == null) { var t = e.parseElement("nakedString", r) } if (t == null) { e.raiseParseError(r, "Expected a URL") } var n = e.parseElement("objectLiteral", r); var o = "text"; if (r.matchToken("as")) { if (r.matchToken("json")) { o = "json" } else if (r.matchToken("response")) { o = "response" } else if (r.matchToken("text")) { } else { e.raiseParseError(r, "Unknown response type: " + r.currentToken()) } } var u = { url: t, argExrepssions: n, args: [t, n], op: function (n, e, a) { return new Promise(function (r, t) { fetch(e, a).then(function (e) { if (o === "response") { n.it = e; r(i.findNext(u)) } else if (o === "json") { e.json().then(function (e) { n.it = e; r(i.findNext(u)) }) } else { e.text().then(function (e) { n.it = e; r(i.findNext(u)) }) } }).catch(function (e) { i.triggerEvent(n.me, "fetch:error", { reason: e }); t(e) }) }) } }; return u } }) } function e(e) { if (document.readyState !== "loading") { e() } else { document.addEventListener("DOMContentLoaded", e) } } function i() { var e = document.querySelector('meta[name="htmx-config"]'); if (e) { return r(e.content) } else { return null } } function c() { var e = i(); if (e) { _hyperscript.config = o(_hyperscript.config, e) } } if ("document" in A) { e(function () { c(); C.processNode(document.body); document.addEventListener("htmx:load", function (e) { C.processNode(e.detail.elt) }) }) } return { internals: { lexer: R, parser: L, runtime: C }, addFeature: function (e, r) { L.addFeature(e, r) }, addCommand: function (e, r) { L.addCommand(e, r) }, addLeafExpression: function (e, r) { L.addLeafExpression(r) }, addIndirectExpression: function (e, r) { L.addIndirectExpression(r) }, evaluate: function (e) { return C.evaluate(e) }, processNode: function (e) { C.processNode(e) }, config: { attributes: "_, script, data-script" } } }() });